C LANGUAGE NOTES

READING LIST

CONTENTS //////////////////////////////////////////////////////////////////////////////////////////
* DATA TYPES
* ARRAYS
* COMMAND-LINE ARGUMENTS
* DATA STRUCTURES
* OTHER NOTES
* RECURSION
* POINTERS
* OVERFLOW

THE C LANGUAGE ////////////////////////////////////////////////////////////////////////////////////

# COMPILING
	gcc -o [executable_name] [source_file].c
	// without the square brackets
	// -o means outfile

# DATA TYPES
	bool				: boolean expression
	char				: a single character
	double				: floating-point value with more digits than float
	float				: floating-point value
	int				: integers up to a certain number of bits
	long				: integers with more bits than int

# ARRAYS
	Elements of arrays can be treated as variables
	Arrays cannot be treated as variables

	Assignment of one array to another using the = operator is not possible in C
	It has to be done iteratively

	Declaring arrays
		type var[n] = { val1, val2, val3 };
		// n is not required, compiler can figure it out if elements are provided in
			curly brackets
		// n should be the number of elements in the array

	This is also possible:
	type var[n][n];

	Using arrays in functions:
		type func_name(type array[])
			// For prototype and declaration
		
		func_name(var)
			// during invocation, no [] on var

# COMMAND-LINE ARGUMENTS
	int main(int argc, string argv[])
	// argc is the argument count
	// argv is the argument vector
	// the program name counts as the first argument
	// the argument vector will contain [program name, argument, argument, ..., null-pointer]

# DATA STRUCTURES
	Define new data type:
		
		typedef struct
		{
			string name;
			string number;
		}
		person; // name of new struct

	Newly defined data type can be used to define new arrays/variables
		
		person people[2];

		people[0].name = "Sample1";
		people[0].number = "+1-234-567";

	Dot notation, as seen above, can be used to access the newly defined data type

# RECURSION
	Function calling itself
	Can be terminated by providing base case
	Base case: a solution that stops the recursive process

	void draw(int n)
	{
		// If nothing to draw
		if (n <= 0)					// this is the base case
		{
			return;
		}

		// Draw pyramid of height n - 1
		draw(n - 1);					// this is the recursive case

		// Draw one more row of width n
		for (int i = 0; i < n; i++)
		{
			printf("#");
		}
		printf("\n");
	}
	
# POINTERS AND MEMORY
	pointer				- variable that contains the address of some value
		Example:

		int n = 50;
		int *p = &n;

		n contains 50, p is a pointer that contains the address of n


	%p				: print out address to which a pointer refers
	&				: provide address
	*				: pointer, go to this location in memory

	Comparing two identical-looking strings using the == operator will result in false
		because what's being compared are actually the addresses
	
	malloc				: allocate memory with specific size
					: can return NULL if something goes wrong

		Example:
		int *n = malloc(size);

	free				: free memory allocated with malloc
		
		Example:
		free(n); // in relation to malloc example

	If, for example, strcpy doesn't exist, when creating an identical copy, use malloc to
		allocate memory for the copy, and then string2[0] = string1[0]
	
	Not using malloc before doing string2[0] = string1[0] will result in both pointing to
		the same memory address
	
	valgrind			: a program that can be used to check memory-related issues
					: checks if all malloc'd memory are free'd

	scanf				: gets input and stores in variable address
		Example:

		int n;
		scanf("%i", &n);

# OVERFLOW
	heap overflow			: accessing areas of memory not supposed to be touched
	stack overflow			: happens when too many functions are called
	buffer overflow			: both heap and stack overflow are considered buffer overflow

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# OTHER NOTES
	Preprocessing			- header files in code are included
	Compiling			- written code is converted to assembly code
	Assembling			- assembly code is converted to machine code
	Linking				- code from included libraries also converted
						to machine code, then combined with
						user's code. Executable file is then
						outputted

	Passed by value			- most variables in C are passed by value
					- arrays are an exception
					- means that a local copy is created in the receiving variable,
						the passing variable is unaffected by changes made to
						receiving variable
	Passed by reference		- arrays, pointers
					- passing variable and receiving variable both point to the
						same memory address
					- modifications to passing variable will affect receiving 
						variable, vice versa
