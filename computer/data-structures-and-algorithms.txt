DATA STRUCTURES AND ALGORITHMS

READ / WATCH LIST
- A Common-sense Guide to Data Structures and Algorithms (Jay Wengrow): position 72.6 / 1076

SOURCES
- The Last Algorithms Course You'll Need (The Primeagen)
- Introduction to Algorithms, third edition (Thomas Cormen)
- A Common-Sense Guide to Data Structures and Algorithms (Jay Wengrow)

CONTENTS
* DEFINITIONS
* DATA STRUCTURE OPERATIONS
* ARRAYS
* SETS
* BIG O NOTATION

ALGORITHMS ////////////////////////////////////////////////////////////////////////////////////////
# DEFINITIONS
	Time complexity		: the speed of an operation
				: measuring the speed of an operation is also known as measuring
					its time complexity

# DATA STRUCTURE OPERATIONS
	Read			: looking something up by using a reference (usually the index)
				: in an array, this can be done in constant time since the
					index is provided
	Search			: checking if a particular value exists, and then possibly
					returning the index number (if array) of that value
				: in an array, the time complexity is O(n) since in the worst
					case scenario, the computer will have to go through
					all of the elements before finding the value being
					searched for or figuring out that the value doesn't
					exist in the array
	Insert			: adding new value/s to data structures
				: in an array, O(n) (technically n + 1 but the constant 1 is
					disregarded in Big O notation)
				: in the worst case, all elements have to be shifted one place
					to make space for the insertion
	Delete			: removing value/s from data structures
				: in an array, also O(n)

# ARRAYS
	Contiguous block of memory used to store values of same data type (in C, at least)

# SETS
	A data structure that doesn't allow duplicates
	For array-based sets:
		The time complexity of reading and searching is the same with arrays
		Inserting takes 2n steps (in arrays, only n steps) because the array
			has to be searched for duplicates, and then the insertion
			happens after the elements have been shifted to make space

# BIG O NOTATION
	Not an exact measurement, generalizes growth of algorithms
	Used to categorize algorithm time or memory requirements based on input
	Informs about the performance of algorithms and data structures

	How does the growth of the input affect performance and memory requirement?
	
	Capital letter O	: worst case (upper bound)
	Capital theta		: best case (lower bound) and worst case (upper bound) are the same
	Constants are dropped out

	In cases where the data set is small enough, slower algorithms with faster starts may still
		be used instead of faster algorithms with slower starts

	EXAMPLE 1 ( Linear, or O(n) )
		Take a string and iterate over it
		For every unit of the string, the loop has to be executed again
		The growth is LINEAR

	EXAMPLE 2 ( Constant time, or O(1) )
		Reading from an array takes the same number of steps no matter the size of input
	
	EXAMPLE 3 ( O(n^2) )
		A loop within a loop where a string is iterated over twice
	
	EXAMPLE 4 ( O(log n) )
		Binary search
		Divide in half for each iteration
